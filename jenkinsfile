def gradlebuil(){
  env = sandbox
  santiytest =no


}

gradlebuil.groovy

pipeline{
agent {
label = 'dev'
}
stages{
  stage = 'sandbox' {
   steps{
   script{
   sh "echo  this is sandbox"
   docker build .agent
   d
   }
   stage  = ""{}
   }
   stage = 'devl'{
   }

}
psot {
whenallof {
expreseeion {
}}}


}


#!/bin/bash

status_code=$(curl --write-out %{http_code} --silent --output /dev/null www.bbc.co.uk/news)

if [[ "$status_code" -ne 200 ]] ; then
  echo "Site status changed to $status_code"
else
  exit 0
fi

curl --write-out %{http_code} --output /dev/null www.facebook.com/bin
if [[ "$status-code" -ne 200 ]]; then


#!bin/bash

echo "enter in"
read frist_name
echo "the $frist-name is "



#!/usr/bin/env groovy
// ToDo::: Adding this file to merge all the gradle build groovy
import com.deere.common.JenkinsHelper

import
def call(map parms = [:]) {
def jenkinsHelper = new jenkinsHelper(this, scm, env, params, cutremtbuli)

pipeline{
agent {
label "
"}

environment
}}

def call(Map params = [:]) {
  def jenkinsHelper = new JenkinsHelper(this, scm, env, params, currentBuild)

  pipeline {
    agent {
      label "${ECOMMERCE_DEVL_BUILD_AGENT}"
    }

    // this options block to delete the older builds
    /*
    options {
      buildDiscarder(
        logRotator(daysToKeepStr: '14', numToKeepStr: '10')
      )
    }
    */

    environment {
      centralDockerImageName = "741640740336.dkr.ecr.${aws_region}.amazonaws.com/${params.serviceName}"
      JOB_BASE_NAME = "${JOB_BASE_NAME}".toLowerCase()
      GH_CREDENTIALS = credentials('di-github-package-rw')
      RELEASE_PREFIX = "release"
    }

    stages {
      stage("Config Default Values") {
        steps {
          script {
            echo "Input Paramsters::: ${params}"
            jenkinsHelper.defaultConfigs(params)
            // Setting default values for missing param
            echo "Parameters post default value::: ${params}"
          }
        }
      }

      stage("Git Checkout") {
        options {
          timeout(time: 10, unit: 'SECONDS')
        }
        steps {
          script {
            // Skip the build if the last commit message has [ci skip] or [skip ci] tag
            try {
              jenkinsHelper.skipCheck()
            } catch (Exception e) {
              steps.sh "echo \"'[ci skip]' or '[skip ci]' tag found in git commit message. ABORTING... \""
              steps.sh "sleep 12"
            }

            // Check the GitHub Repo and read the first 8 characters from the GIT Commit ID
            GIT_COMMIT = jenkinsHelper.checkout()
            IMAGE_TAG = GIT_COMMIT
          }
        }
      }

      stage("Build & Run Unit Tests") {
        steps {
          script {
            if (env.GIT_BRANCH ==~ /origin\/r\d+(?:\.\d+)+/ || "${params.skipSonarQube}".toBoolean()) {
              sh "docker-compose -f docker-compose-ci.yml run --name ${params.serviceName}_${GIT_COMMIT} ${params.serviceName} clean check build --info"
            } else {
              withSonarQubeEnv("JDStoreSonarQube") {
                steps.sh "docker --version"
                jenkinsHelper.gradleBuildAndTest("${params.serviceName}", "${GIT_COMMIT}")
              }
            }
          }
        }

        post {
          always {
            script {
              sh "docker cp ${params.serviceName}_${GIT_COMMIT}:/app/build ./build || true"
              sh "docker-compose -f docker-compose-ci.yml down"

              // Remove docker image which generated by docker-compose
              jenkinsHelper.removeDockerImage("${JOB_BASE_NAME}_${params.serviceName}")
            }
          }
        }
      }

      // TODO: Merge this stage into the previous one - so that the running container can be reused to generate the schema diagrams. Otherwise its a huge increase in build timing that's unnecessary
      stage("DB Schema Generator") {
        steps {
          script {
            jenkinsHelper.dbSchemaGenerator("${params.serviceName}", "${GIT_COMMIT}")
          }
        }

        post {
          always {
            script {
              // Removing the docker container from background process
              sh "docker-compose -f docker-compose-ci.yml down"

              // Remove docker image which generated by docker-compose
              jenkinsHelper.removeDockerImage("${JOB_BASE_NAME}_${params.serviceName}")
            }
          }
        }

        when {
          anyOf {
            expression {
              "${params.skipGenerateDBSchema}".toBoolean() != true
            }
          }
        }
      }

//       stage("Docker Hadolint") {
//         steps {
//           script {
//             jenkinsHelper.dockerLint()
//           }
//         }
//       }

      stage("Build Docker Image") {
        steps {
          script {
            if (env.GIT_BRANCH ==~ /origin\/r\d+(?:\.\d+)+/)
              IMAGE_TAG = "${RELEASE_PREFIX}-${GIT_COMMIT}"
            jenkinsHelper.dockerBuild("${centralDockerImageName}:${IMAGE_TAG}", "--build-arg GH_CREDENTIALS_USR=${GH_CREDENTIALS_USR} --build-arg GH_CREDENTIALS_PSW=${GH_CREDENTIALS_PSW} .")
          }
        }
      }

      stage("Scan Docker Image for Vulnerability") {
        steps {
          catchError(buildResult: "SUCCESS", stageResult: "FAILURE") {
            script {
              jenkinsHelper.trivyInstall()
              jenkinsHelper.scanDockerImage("${centralDockerImageName}:${IMAGE_TAG}")
            }
          }
        }
      }

      // This stage runs only when the Jenkins Job triggered from Master in branch
      stage("Push Docker Image into AWS ECR") {
        steps {
          script {
            if (env.GIT_BRANCH ==~ /origin\/r\d+(?:\.\d+)+/)
              IMAGE_TAG = "${RELEASE_PREFIX}-${GIT_COMMIT}"
            jenkinsHelper.dockerPush("${centralDockerImageName}:${IMAGE_TAG}", [], "741640740336", "${aws_region}")
          }
        }

        when {
          // Docker images pushed into ECR only from master branch
          allOf {
            expression {
              "${params.skipDeployment}".toBoolean() != true
            }

            anyOf {
              expression {
                env.GIT_BRANCH == "origin/master"
              }
              expression {
                env.GIT_BRANCH == "origin/main"
              }
              expression {
                env.GIT_BRANCH ==~ /origin\/r\d+(?:\.\d+)+/
              }
            }
          }
        }
      }

      // Publish test results.
      stage("Publish Test Result") {
        steps {
          script {
            // Publish test results
            jenkinsHelper.publishHTMLReports()
          }
        }

        when {
          anyOf {
            expression {
              env.GIT_BRANCH == "origin/master"
            }
            expression {
              env.GIT_BRANCH == "origin/main"
            }
            expression {
              env.GIT_BRANCH ==~ /origin\/r\d+(?:\.\d+)+/
            }
          }
        }
      }
    }

    post {
      success {
        script {
          currentBuild.result = "SUCCESS"

          if ((env.GIT_BRANCH == "origin/main" || env.GIT_BRANCH == "origin/master") && ("${params.skipDeployment}".toBoolean() != true)) {
            // Invoking deployment pipeline with Input parameters
            print(" ******* Invoking the CD Pipeline ******* ")
            build wait: false, job: "ecommerce-continuous-deployment/${params.cdJob}", parameters: [
              [$class: "StringParameterValue", name: "EKS_ENVIRONMENT", value: "SANDBOX"],
              [$class: "StringParameterValue", name: "SERVICE_NAME", value: "${params.serviceName}"],
              [$class: "StringParameterValue", name: "DOCKER_IMAGE_TAG", value: "${GIT_COMMIT}"]
            ]
          }

          def previousResult = currentBuild.previousBuild?.result
          if (previousResult && previousResult != currentBuild.result) {
            // Send Build Notification to MS Teams
            withCredentials([string(credentialsId: "${params.msTeamWebHook}", variable: 'msTeamWebHook')]) {
              jenkinsHelper.buildNotification("Jenkins CI Build Notification \n\nJob Name: ${env.JOB_NAME} \n\nBuild Number: ${env.BUILD_NUMBER} \n\nGit Commit: ${env.GIT_COMMIT} \n\n", "${currentBuild.result}", "${msTeamWebHook}")
            }
          }
        }
      }

      failure {
        script {
          currentBuild.result = "FAILURE"
          // Publish test result incase of build failure
          jenkinsHelper.publishHTMLReports()
          // Removing the docker container from background process
          sh "docker-compose -f docker-compose-ci.yml down || true"

          // Remove docker image which generated by docker-compose
          jenkinsHelper.removeDockerImage("${JOB_BASE_NAME}_${params.serviceName}")

          // Send Build Notification to MS Teams
          withCredentials([string(credentialsId: "${params.msTeamWebHook}", variable: 'msTeamWebHook')]) {
            jenkinsHelper.buildNotification("Jenkins CI Build Notification \n\nJob Name: ${env.JOB_NAME} \n\nBuild Number: ${env.BUILD_NUMBER} \n\nGit Commit: ${env.GIT_COMMIT} \n\n", "${currentBuild.result}", "${msTeamWebHook}")
          }
        }
      }

      aborted {
        script {
          currentBuild.result = "ABORTED"

          // Removing the docker container from background process
          sh "docker-compose -f docker-compose-ci.yml down || true"

          // Remove docker image which generated by docker-compose
          jenkinsHelper.removeDockerImage("${JOB_BASE_NAME}_${params.serviceName}")
        }
      }

      always {
        script {
          // Updating Jenkins Build Name
          currentBuild.displayName = "#" + (currentBuild.number + " - ${IMAGE_TAG}")


          // Remove docker image which generated by docker-compose
          jenkinsHelper.removeDockerImage("${JOB_BASE_NAME}_${params.serviceName}")

          // Set current build result if skipped
          jenkinsHelper.skipPostProcess()

          // The below cleanWs() causing issue while publishing the test results.
          // cleanWs()
        }
      }
    }
  }
}



